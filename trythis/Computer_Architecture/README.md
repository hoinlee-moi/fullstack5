## 컴퓨터 구조
### 중앙처리장치 (CPU)
컴퓨터를 직접 맞춰봤다면 한번쯤을 들어봤을 cpu이다. 아마 컴퓨터를 맞출 때 CPU,VGA,RAM 이렇게 제일 많이들보지 않았을까 싶다.<br>
cpu는 컴퓨터에서 가장 중요한 구성요소중 하나로 컴퓨터의 모든 작업을 제어하고 수행한다.<br>
프로그램의 명령어를 해석하고 실행하는 역할도 포함되며 산술논리연산장치(ALU), 제어 장치, 레지스터 증으로 구성되어 있다.<br>

### 주 기억장치(main memory)
컴퓨터가 사용하는 데이터를 저장하는 장치.<br>
주 기억장치(RAM)와 보조 기억장치(HDD,SSD 등)로 구성된다. <br>
주 기억장치는 CPU가 바로 접근할 수 있는 장치로 CPU가 프로그램 실행을 실행할 때 필요한 데이터와 명령어를 저장한다. <br>
컴퓨터가 꺼지면 모든 데이터가 날아가는 휘발성을 가지고 있고, 저장할 수 있는 데이터 용량이 보조 기억장치에 비해 적다
- 보통 HDD나 SSD는 256기가부터 1TB 2TB 등 매우 커지는 반면 RAM은 8G부터 16G, 32G등 보조 기억장치들보다 적은게 한눈에 보인다.
- 윈도우 컴퓨터를 오래 켜놓고 있으면 메모리 저장시 빈공간이 발생하고 디스크 정리를 해줘야 하곤 했다. 그래서 컴퓨터 전원을 껐다 키면 원래대로 돌아왔었는데 이게 휘발성과 연관 되어 있는 것 같다.

### 입출력 장치(Input/Output Devices)
컴퓨터와 사용자간의 상호작용을 돕는 장치로 모니터,키보드 마우스등이 있다.<br>
입력 장치는 키보드 마우스 같은 컴퓨터에게 데이터를 입력해 주는 장치고 모니터 스피커등 우리에게 보내주는 것이 출력장치

### 보조 기억 장치(Storage=Secendary Memory)
데이터를 임시적, 반영구적으로 저장하는 장치. HDD,SSD,USB플래시 드라이브 등이 있고 보조 기억장치는 주기억장치와는 달리 느리지만 대용량 데이터를 저장가능하다

### Bus
컴퓨터 내부에서 데이터와 명령어를 전송하는 통로로 데이터버스, 주소 버스, 제어버스 등으로 나눠져 있다.
- Address Bus(주소 버스) : 메모리 주소를 보내주는 통로
  - CPU와 메모리는 단방향으로 데이터 전달이 가능한 버스를 이용함, 주소 전달은 CPU에서 메모리로만 가능
- Data Bus(데이터 버스) 는 데이터 값을 보내주는 통로
  - 각 구성요소는 양방향으로 데이터 전달이 가능한 버스를 사용
- Control Bus(제어 버스) 제어 신호를 전달하는 통로
  - Read와 Write 신호가 전달
  

## 컴퓨터 동작 
![](https://velog.velcdn.com/images/lee_moi/post/1bd8444e-a755-4eee-a53c-f08cc0e5fd08/image.png)

보면 왼쪽에 커다란 네모
ALU, CU, Register, Data Register, Cache Memory(L2까지지만 최근 컴퓨터들은 그 이상까지도 cpu에 포함시키고 있다) CPU영역이 있고
시스템 버스를 통해 주 기억장치와 데이터와 신호등을 주고 받는다

`STORE` 어셈블리 코드로 어셈블리 코드가 무엇인지 먼저 알아보자

> ### 어셈블리어
CPU 프로세서에 명령을 내리기 위해 고유의 명령어 세트가 마련되어 있다.<br>
이 명령어 세트를 기계어라고 하는데 이 기계 명령어들은 프로그래밍에상당히 난해해서 좀더 이해하기 쉬운 기호 코드로 나타낸걸이 어셈블리어이다.(결국 2진수 코드로 바뀜)<br>
즉, 기계어와 1:1 대응하는 언어이며 배우면 시스템을 이해하는데 도움이 된다.

### 인출사이클
- 처음 프로그램 카운터(PC)를 통해 명령어 주소를 가지게 되면 CPU 내부 버스를 통해 MAR로 보낸다
  - 여기서 **MAR**(Memory Address Register) 이란?
  기억장치 주소 레지스터로 접근할 메모리의 주소를 임시로 저장한다.
  프로그램 카운터에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전에 일시적으로 저장하는 	레지스터이다

- 시스템 버스와 직접 접속된 MAR을 통해서 주소(인출할 명령어의 주소)가 기억장치로 전송
- 해당 기억장치 주소로부터 읽혀진 명령어가 데이터 버스를 통해서 MBR에 적재
  - 여기서 **MBR**(Memory Buffer Register)이란??
  주 기억장치(메모리)에서 읽어온 Data/ 주 기억장치에 저장할 Data를 임시 저장하는 버퍼 레지스터
  Data를 처리하기 위해 반드시 거쳐가는 곳이다
  
- 이후 프로그램 카운터 내용에 1을 더해서 다음 명령어 주소를 가리키게 한다.
- MBR에 저장되어 있는 명령어를 IR로 이동
  - 여기서 **IR**(Instruction Register)이란?
  명령어 레지스터로 현재 실행중인 명령어를 저장하는 레지스터(여기선 store가 될 것)<br><br>
  
![](https://velog.velcdn.com/images/lee_moi/post/7595176c-80c6-4392-8a9a-68d85130d64c/image.png)

확실하게 이해하고 나니 이 그림이 이해가 간다<br>
우리가 입력한 코드 `store 1 &A`라는 코드를 cpu가 어떻게 처리하느냐?를 봤을 때
프로그램 카운터가 해당 코드 줄 명령어가 있는 위치 주소를 알려준다<br>
이유는?<br>
현재 메모리에는 사용자의 프로그램들과 운영체제들이 수행되고 있기 때문에 cpu가 무엇을 실행할지는 프로그램 카운터가 가리키는 메모리 위치의 프로그램을 수행하는 것이다.<br>
이제부터 프로그램 카운터는 PC라고 부르겠다<br>

PC에서 불려진 명령어 주소는 CPU내부 버스를 통해 MAR에 잠깐 저장한다.<br> 그리고 MAR을 통해 기억장치로 주소(명령어가 아니라 주소다)를 시스템 버스를 통해 전송한다<br>
기억장치에서 해당 주소를 통해 명령어를 읽어와서 시스템버스를 통해 다시 CPU내의 MBR에 저장한다.<br>
이후 프로그램 카운터는 다음 명령어 주소를 가리키고 MBR은 현재 저장하고 있는 명령어를 IR로 보낸다<br>

여기까지가 인출 사이클이다. 이후 실행사이클을 다뤄보자<br>

---
### 실행사이클
CPU가 IR에 저장된 명령어를 해독하고 해당 결과에 따라 필요한 연산을 수행한다

#### Data 이동
IR 에 저장된 명령어의 operand를 MAR을 경유해서 기억장치로 보내 Data를 인출
  - 여기서 operand란?
  operand는 명령어가 사용할 Data가 저장되어 있는 기억장치의 주소를 가리킨다

위에서 진행했던 인출처럼 IR에 저장되어 있는 명령어의 operand 주소를 MAR을 통해 기억장치로 보낸다<br>
해당 주소가 지정하는 기억장치로부터 Data를 인출해서 MBR에 저장한다
해당 Data를 AC(누산기)에 저장한다<br><br>
![](https://velog.velcdn.com/images/lee_moi/post/7dceb44a-f555-415e-98f3-b0a21338db5d/image.png)

아까 인출 과정에선 IR에서 끝났는데 해당 IR에 저장된 명령어가 사용할 Data 주소를 인출과 동일하게 MAR을 통해서 메모리로 보내고 메모리에서 데이터를 가져와서 MBR로 저장한후 내부 버스를 통해 AC에 저장시킨다가 이해된 과정이다

#### Data 저장
AC의 DATA를 기억장치에 저장

먼저 데이터를 저장할 기억장치의 주소를 MAR로 보내고 저장할 DATA를 MBR로 보낸다.<br>
즉, Data를 저장할 주소와 저장할 Data를 각각 MAR과 MBR에 저장
해당 주소가 지정하는 기억장치에 Data를 저장<br><br>
![](https://velog.velcdn.com/images/lee_moi/post/c459d78b-c624-44b0-ad4f-fd8450d4abde/image.png)

IR에 입력되어있는 명령어에서 어디에 저장할 것인지 주소를( store 1 &A일 때 A부분이 메모리 주소라고 보면 된다) MAR에 보내고 AC에 저장된 Data는 MBR에 보내서 함께 시스템 버스를 통해 Main memory로보낸다
라고 이해했다

### Data 처리
기억장치에 저장된 Data를 AC의 Data와 더하고, 해당 결과를 다시 AC에 저장
`ADD`라는 연산을 처리한다 했을 때이다

명령어의 operand를 주소버스를 경유해서 MAR로 보낸다<br>
해당 명령어의 주소인 기억장치의 주소로부터 Data를 인출해서 MBR에 저장
AC에 저장된 Data , MBR에 저장된 Data를 더하고, 해당 결과를 AC에 저장<br><br>
![](https://velog.velcdn.com/images/lee_moi/post/3c724be4-8575-4c08-b151-4a6830a3beca/image.png)

이 과정에서 만약 AC에 필요한 데이터 값이 모두 있다면 굳이 기억장치에서 Data를 가져오지 않고 AC에 저장된 데이터로 ALU 연산을 실행해서 저장한다라고 이해한 부분도 있다.<br>
일단 흐름을 보자면 IR에서 명령어를 실행할 때 AC에 없는 데이터가 있다면 MAR을 통해 주소를 메모리로 전달하여 DATA를 가져와 MBR에 저장한다.<br>
그리고 만약 AC에 필요한 데이터가 있다면 AC에서 ALU로 가져오고 MBR에서 ALU로 데이터를 가져와서 연산한다.<br>
이때 해당 결과를 AC에 저장


### 프로그램 제어
일반적인 명령어들은 기억장치에 저장된 순서대로 실행하기에 실행 순서를 결정할 필요는 없다.(프로그램 카운터가 결정한다)<br>
**완전히 다른 위치에 있는 명령어를 실행할 경우**
JUMP같은건 PC가 다른 위치의 명령어를 실행하게 만든다

명령어의 operand는 분기 목적지 주소를 가리키기 때문에, 해당 주소를 PC에 적재하면 된다<br>
이런 과정을 통해서, PC의 내용이 변경됨에 따라, 명령어의 실행 순서도 변경된다.<br><br>
![](https://velog.velcdn.com/images/lee_moi/post/907dbfef-a20c-41d3-8212-4edc8c923fe4/image.png)

여기서 명령어의 데이터 주소가 목적지 주소를 가리키기 때문에 해당 주소를 바로 PC에 적재해서 다음 PC순서는 자동적으로 변경된 주소가 들어가서 실행되게 된다.


여기까지가 CPU가 동작되는 방식이다. 시스템 버스에는 각각 주소와 데이터 제어를 따로따로 보낼 수 있는 버스가 있는 것 까지 기억하자

---
###  Hit Ratio
여기서 중요한 부분이 또 있는데 캐시 메모리와 Hit Ratio이다<br>
캐시 메모리는 cpu의 연산 속도에 비해 메모리에서 데이터를 찾아오는 과정에서 시간차이가 생기기 때문에 빠르게 실행하기 위해 자주 쓰거나 최근에 쓰인 메모리 데이터들을 cpu 안 메모리에 저장시키는 것이다.<br><br>
**Hit Ratio는 공간/시간 지역성**
즉 한번 사용한 데이터는 다시 사용할 수 있고 그 주변의 데이터를 곧 사용할 가능성이 높다
데이터 지역성을 활용해서 메인 메모리에 있는 데이터를 캐시 메모리에 불러와 두고 CPU가 필요한 데이터를 캐시에서 먼저 찾도록 하게 한다
즉, Hit Ratio가 좋을 수록 좋은 프로그램이라고도 할 수 있지 않을까 싶다.

<br>

[Compiler & OS보러가기](https://github.com/hoinlee-moi/fullstack5/blob/main/trythis/Computer_Architecture/README(compile).md)

### Reference
[CPU의 기본구조](https://cs-ssupport.tistory.com/307)

[시니어코딩](https://www.youtube.com/@SeniorCoding) - 새싹 풀스택 실무 프로젝트 과정